package org.maxicp.cp.engine.core.mdd;

import org.maxicp.cp.engine.core.CPIntVar;
import org.maxicp.cp.engine.core.mdd.properties.MDDInt;
import org.maxicp.cp.engine.core.mdd.properties.MDDProperty;
import org.maxicp.state.datastructures.SmallBitSet;

import java.util.*;
import java.util.function.Function;

public abstract class MDDSpecs<T> {

    // properties sorted in up and down categories
    private MDDProperty[] upProperties;
    private MDDProperty[] downProperties;
    private int nbUpProperties;
    private int nbDownProperties;

    protected List<CPIntVar> variables;
    protected HashMap<String, Function<T, Integer>> exposures = new HashMap<>();
    protected HashMap<String, Function<T, MDDInt>> propertyExposure = new HashMap<>();
    protected HashMap<String, Function<T, SmallBitSet>> smallBitSetExposure = new HashMap<>();


    public MDDSpecs(int nbUpProperties, int nbDownProperties) {
        this.upProperties = new MDDProperty[nbUpProperties];
        this.downProperties = new MDDProperty[nbDownProperties];
        this.nbUpProperties = 0;
        this.nbDownProperties = 0;
    }

    public MDDSpecs() {
        this(10,10);
    }

    private void growUp() {
        if (nbUpProperties >= upProperties.length) {
            MDDProperty[] temp = new MDDProperty[nbUpProperties + 5];
            System.arraycopy(upProperties, 0, temp, 0, nbUpProperties);
            upProperties = temp;
        }
    }

    private void growDown() {
        if (nbDownProperties >= downProperties.length) {
            MDDProperty[] temp = new MDDProperty[nbDownProperties + 5];
            System.arraycopy(downProperties, 0, temp, 0, nbDownProperties);
            downProperties = temp;
        }
    }

    public void addProperty(MDDProperty property) {
        if (property.isUpProperty()) {
            growUp();
            upProperties[nbUpProperties] = property;
            nbUpProperties++;
        } else if (property.isDownProperty()) {
            growDown();
            downProperties[nbDownProperties] = property;
            nbDownProperties++;
        } else
            System.out.println("unsuported direction");
    }

    public MDDProperty[] getUpProperties() { // TODO to be removed
        return upProperties;
    }

    public int nbUpProperties() {
        return this.nbUpProperties;
    }

    public MDDProperty[] getDownProperties() { // TODO to be removed
        return downProperties;
    }

    public int nbDownProperties() {
        return this.nbDownProperties;
    }

    /***
     * A user can dynamically specify a function that will expose a value of the spec (see addExposure)
     * This value could be use to define heuristics for instance. This function returns the exposed values of this specificator.
     * @return a hash map containing all the calculated and exposed values, the key is specified in addExposure.
     */
    public Map<String, Integer> getExposedValues(){
        Map<String, Integer> result = new HashMap<>();
        for (Map.Entry<String, Function<T, Integer>> entry : exposures.entrySet()) {
            result.put(entry.getKey(), entry.getValue().apply(this.getSpec()));
        }
        return result;
    }

    public Map<String, MDDInt> getExposedProperty(){
        Map<String, MDDInt> result = new HashMap<>();
        for (Map.Entry<String, Function<T, MDDInt>> entry : propertyExposure.entrySet()) {
            result.put(entry.getKey(), entry.getValue().apply(this.getSpec()));
        }
        return result;
    }

    public Map<String, SmallBitSet> getExposedSmallBitSet(){
        Map<String, SmallBitSet> result = new HashMap<>();
        for (Map.Entry<String, Function<T, SmallBitSet>> entry : smallBitSetExposure.entrySet()) {
            result.put(entry.getKey(), entry.getValue().apply(this.getSpec()));
        }
        return result;
    }

    public boolean isRelaxedDown() {
        /*for (MDDProperty prop : upProperties) {
            if (prop.isRelaxedDown()) return true;
        }*/
        for (MDDProperty prop : downProperties) {
            if (prop.isRelaxed()) return true;
        }
        return false;
    }

    public boolean isRelaxedUp() {
        for (MDDProperty prop : upProperties) {
            if (prop.isRelaxed()) return true;
        }
        return false;
    }

    /***
     * If a value derived from the spec attributes needs to be exposed, this method could be called.
     * @param key the key to retrieve the value in the hashmap generated by getExposedValues
     * @param exposureFunction compute a value based on the specificator
     */
    public void addExposure(String key, Function<T, Integer> exposureFunction) {
        exposures.put(key, exposureFunction);
    }

    public void addIntPropertyExposure(String key, Function<T, MDDInt> exposureFunction) {
        propertyExposure.put(key, exposureFunction);
    }
    public void addBitSetExposure(String key, Function<T, SmallBitSet> exposureFunction) {
        smallBitSetExposure.put(key, exposureFunction);
    }

    /***
     * Relax two specs to allow node merging. Calls the relax function specified in the properties
     * @param spec the spec with which the relaxation is done
     */
    public void relax(MDDSpecs<T> spec){
        for(int i = 0; i<spec.nbUpProperties();i++){
            this.upProperties[i].update(spec.upProperties[i].getValue(), false);
        }
        for(int i = 0; i<spec.nbDownProperties();i++){
            this.downProperties[i].update(spec.downProperties[i].getValue(), false);
        }
    }

    public List<CPIntVar> getVariables(){
        return this.variables;
    }



    /***
     * copies the up properties of another spec, used when updating a state value
     * @param spec the spec from which the properties are copied.
     */
    public void updateUpProperties(MDDSpecs<T> spec, boolean forceUpdate) {
        for (int i = 0; i < nbUpProperties(); i++) {
            upProperties[i].update(spec.getUpProperties()[i].getValue(), forceUpdate);
        }
    }

    /***
     * copies the down properties of another spec, used when updating a state value
     * @param spec the spec from which the properties are copied.
     */
    public void updateDownProperties(MDDSpecs<T> spec, boolean forceUpdate) {
        for (int i = 0; i < nbDownProperties(); i++) {
            downProperties[i].update(spec.downProperties[i].getValue(), forceUpdate);
        }
    }

    public MDDSpecs<T> clone(){
        MDDSpecs<T> spec = getInstance();
        for(int i = 0; i<spec.nbDownProperties();i++){
            spec.downProperties[i].getProperty().copy(this.downProperties[i]);
        }
        for(int i = 0; i<spec.nbUpProperties();i++){
            spec.upProperties[i].getProperty().copy(this.upProperties[i]);
        }
        spec.exposures = this.exposures;
        spec.propertyExposure = this.propertyExposure;
        spec.smallBitSetExposure = this.smallBitSetExposure;
        return spec;
    }

    /***
     * Function that determines if an arc (assignation of a value to a variable) is possible in the given spec.
     * It should only access the down properties of the source and up properties of the target
     * @param source the spec from which the arc originates
     * @param target the spec to which the arc is headed
     * @param var the variable associated with the arc
     * @param value the value we want to assign the variable
     * @return true if the arc is possible
     */
    public abstract boolean arcExist(MDDSpecs<T> source, MDDSpecs<T> target, CPIntVar var, int value);

    /**
     * Updates the down properties based on a source state and an arc. No need for arcExist call.
     * @param source the spec from which the arc originates
     * @param var the variable associated with the arc
     * @param value the value we want to assign the variable
     */
    public abstract void transitionDown(MDDSpecs<T> source, CPIntVar var, int value, boolean forceUpdate);

    /**
     * Updates the down properties based on a source state and an arc. No need for arcExist call.
     * @param source the spec from which the arc originates
     * @param var the variable associated with the arc
     * @param values the values we want to assign the variable
     */
    public void transitionDown(MDDSpecs<T> source, CPIntVar var, int[] values, int nbValues, boolean forceUpdate) {
        if (nbValues > 0) {
            this.transitionDown(source, var, values[0], forceUpdate);
            for (int i = 1; i < nbValues; i++) {
                this.transitionDown(source, var, values[i], false);
            }
        }
    }

    /**
     * Updates the up properties based on a target state and an arc. No need for arcExist call.
     * Note : to update up properties the data comes from the bottom (target node is the bottom node)
     * @param target the spec to which the arc is headed
     * @param var the variable associated with the arc
     * @param value the value we want to assign the variable
     */
    public abstract void transitionUp(MDDSpecs<T> target, CPIntVar var, int value, boolean forceUpdate);


    /**
     * Updates the up properties based on a target state and an arc. No need for arcExist call.
     * Note : to update up properties the data comes from the bottom (target node is the bottom node)
     * @param target the spec to which the arc is headed
     * @param var the variable associated with the arc
     * @param values the values we want to assign the variable
     */
    public void transitionUp(MDDSpecs<T> target, CPIntVar var, int[] values, int nbValues, boolean forceUpdate) {
        if (nbValues > 0) {
            this.transitionUp(target, var, values[0], forceUpdate);
            for (int i = 1; i < nbValues; i++) {
                this.transitionUp(target, var, values[i], false);
            }
        }
    }

    /**
     * Used in clone, instanciate a basic spec instance with all arguments needed (variables, problem data)
     * @return the instanciated object
     */
    public abstract MDDSpecs<T> getInstance();

    /**
     * To allow a code with no cast. Just write "return this"
     * @return this
     */
    public abstract T getSpec();

    /**
     * Can be used to specify if a variable should be in the middle layer in a sMDD.
     * Can be used for variable ordering heuristics
     * @param var the variable
     * @return true if this variable shoud be in the middle layer
     */
    public boolean middleVariable(CPIntVar var){
        return false;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MDDSpecs mddSpecs = (MDDSpecs) o;
        return Objects.equals(downProperties, mddSpecs.downProperties) && Objects.equals(upProperties, mddSpecs.upProperties);
    }

    @Override
    public int hashCode() {
        int result = 1;
        result = 31 * result + upProperties.hashCode();
        result = 31 * result + downProperties.hashCode();
        return result;
    }

    public long computeHash() {
        long h = 0xC2B2AE35L;
        h = mixList(h, upProperties);
        h = mixList(h, downProperties);
        return h;
    }

    private long mixList(long h, MDDProperty[] props) {
        for (MDDProperty p : props) {
            h ^= (p.toHash() * 0x85EBCA6BL);
            h = Long.rotateLeft(h, 13) * 0x27D4EB2DL;
        }
        return h;
    }
}
